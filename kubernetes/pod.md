## Pod

- 쿠버네티스에서 가장 중요한 개념
- 파드: 하나 이상의 밀접하게 연관된 컨테이너의 그룹 (1~N 개의 컨테이너를 가짐)
  - 파드: 컨테이너 + (컨테이너) + ... + (컨테이너)
- N개의 컨테이너는 모두 같은 워커 노드에서 실행됨
- `자체ip, 호스트 이름, 프로세스` 가 있는 논리적으로 분리된 머신 (논리적 호스트이며, 물리적 호스트와 매우 유사하게 동작함)
- 일시적이다. 파드는 언제든 사라질 수 있다.

&nbsp;

### 파드가 필요한 이유  
Q) 하나의 파드는 여러 컨테이너(N개)를 가진다고 한다. 그런데, 하나의 컨테이너에 여러 프로세스(N개) 를 구성하도록 하면 파드 안써도 되는거 아닌가 ?

A) 아니다. 컨테이너는 단일 프로세스를 실행하는 것을 목적으로 설계했다. 따라서 하나의 컨테이너에는 하나의 프로세스만 구성해야 하며 여러 컨테이너를 묶는 파드가 필요하다.

**(컨테이너에 단일 프로세스로 설계한 이유)**   
하나의 컨테이너에 여러 프로세스를 구성하면 두가지 문제가 있다.  
1. 프로세스 실행
   여러 프로세스를 두면 관리가 힘들어진다. 개별 프로세스가 실패하는 경우 자동으로 재시작(reload)하는 메커니즘이 필요하다.
2. 로그 관리
   모든 프로세스는 표준 출력으로 로그를 기록한다. 이에 어떤 프로세스가 남긴 로그인지 파악하기가 어려워진다.

여러 프로세스를 단일 컨테이너로 묶지 않기에, 컨테이너를 함께 묶고 **하나의 단위로 관리** 할 수 있는 상위 구조가 필요하다. 이 역할을 **파드** 가 수행한다.  

&nbsp;

**동일 파드의 컨테이너와 통신하는 법 : localhost:포트**  
동일한 파드 내 컨테이너들은 모두 동일한 ip주소와 포트 공간을 공유한다.  
이유: 파드 내 모든 컨테이너는 동일한 네트워크 네임스페이스에서 실행되기 때문.  

따라서 각 컨테이너는 사용하는 포트가 달라야 한다.

또한, 동일한 루프백 네트워크 인터페이스를 갖기 때문에, 로컬호스트를 통해 서로 통신한다.  
(루프백 네트워크 인터페이스: 통상적으로 디버깅을 목적으로 네트워크 상에서 자기자신을 나타내는 인터페이스 또는 그 주소. 127.0.0.0 ~ 127,255,255,255)

&nbsp;

**다른 파드의 컨테이너와 통신하는 법 : ip:포트**  
모든 파드는 다른 파드의 ip주소를 사용해 접근하는 것이 가능하다.  
두 파드 사이에 어떠한 NAT(Network Address Translation) 도 존재하지 않는다.  => **플랫 네트워크** 이다.
(NAT: Ipv4의 주소 부족 문제를 해결하기 위한 방법으로 고안되었으며, 주로 비공인 네트워크 주소를 사용하는 망에서 외부의 공인망과의 통신을 위해서 네트워크 주소를 변환하는 것. 즉, 내부 망에서는 사설 ip 주소를 이용하여 통신을 하고, 외부망과의 통신시에는 NAT를 거쳐 공인ip 주소로 자동 변환) 

따라서 파드 사이에서 통신은 항상 단순하다. (NAT가 없으므로 바로 찾아간다, 파드가 어느 워커노드에 있는지 몰라도 된다)

&nbsp;

### 파드 구성하는 법(어떤 컨테이너를 동일한 파드에 넣으면 좋을까에 대한 팁)

파드는 가볍다. 따라서 모든 것을 하나의 파드에 넣을 이유가 없다.  
=> 애플리케이션을 여러 파드로 구성하고, 각 파드에는 밀접하게 관련있는 구성요소나 프로세스만 포함할 것

다음과 같은 질문을 던져라
1. 컨테이너를 함께 실행해야 하는가. 혹은 서롤 다른 호스트에서 실행할 수 있는가?
   eg. 다계층 애플리케이션(백엔드/프론트/DB) 는 쪼개자. 같은머신에서 실행해야할 이유가 없다.
2. 여러 컨테이너가 모여 하나의 구성 요소를 나타내는가, 혹은 개별적인 구성 요소인가?
   하나의 주 컨테이너(eg. 웹서버)와 이를 지원하는 사이드카 컨테이너(로깅 수집을위한 컨테이너 or 볼륨)는 하나의 구성요소
   (사이드카 패턴: 기본 컨테이너의 기능을 확장하거나 강화하는 용도의 컨테이너를 추가하는 패턴)
3. 컨테이너가 함께, 혹은 개별적으로 스케일링돼야 하는가?
   백엔드/프론트 는 스케일링이 필요한 상황이 다르다.

&nbsp;

### 파드 정의하기

정의하는 방법  
1. kubectl run
   - 간단하게 리소스 만들 수 있다
   - 단점: 제한된 속성 집합만 설정 가능
2. yaml (추천!!)
   - 버전 관리 시스템(git)에서 관리할 수 있다.
   - kubectl create -f 이름.yaml

정의 확인하기  
- kubectl get po 이름 -o yaml

로그 확인하기  
- kubectl logs 이름
- 컨테이너 로그는 하루 단위로, 로그 파일이 10MB 도달할 때마다 순환된다
- 주의: 파드가 삭제되면 로그도 삭제된다 => 유실 가능성 있으니 중앙집중식 로깅 필요함

포트 포워딩
- kubectl port-forward 이름 8888:8080
- 로컬호스트 8888포트를 파드의 8080과 포워딩 하겠다  
<img width=300 src="https://user-images.githubusercontent.com/25674959/118762239-da3b3400-b8b0-11eb-999a-9bfcc6911e11.png">

&nbsp;

### 파드와 레이블(label)

클러스터에는 매우 많은 파드가 있을 것임. 서비스가 MSA 인 경우 갯수는 어마어마 함.    
각 파드에 라벨링 가능. 파드 수가 증가함에 따라 파드를 부분집합으로 분류하기 위함    


eg. 서비스명, Phase 등에 따라 레이블 나누기

레이블 생성(yaml)
- metadata.labels

레이블 조회
- kubectl get po -L creation_method,env
  - 파드 출력 시 creation_method,env 레이블도 출력됨
  - create_method,env 키만 존재하는 파드 출력하는 것이 아님(<- 레이블 셀렉터가 함)

레이블 수정
- 신규 키/밸류 추가 시
  - kubectl label po 이름 키=밸류
- 기존 키의 밸류 수정 시
  - kubectl label po 이름 키=밸류 --overwrite

단순히 레이블은 매력적이지 않아보임. 아래의 레이블 셀렉터와 사용할 때 레이블은 강력하다

&nbsp;

### 파드와 레이블 셀렉터

특정 레이블의 파드의 부분 집합을 선택한다.  
-> 특정 레이블만 원하는 작업을 수행하게 할 수 있다.

- 특정 키를 가지거나/가지지않는 레이블
  - kubectl get po -l env
  - kubectl get po -l '!env'
- 특정 키와 값을 가진 레이블
  - kubectl get po -l creation_method=manual
  - kubectl get po -l env in (prod,dev)
- 특정 키를 가지고 다른 값을 가진 레이블
  - kubectl get po -l creation_method!=manual
  - kubectl get po -l env notin (prod,dev)

특정 Phase의 특정 Service의 Pod를 가져오기가 편하다.  
쉽게 찾아낼 수 있음! 👍  
-> 나중에 레플리케이션컨트롤러/서비스 에서 장점이 더 드러남.

&nbsp;

**레이블 셀렉터를 이용한 스케줄링 제한**  

스케줄링: 파드의 개수가 아님. 신규 파드 생성 시 적정 node를 찾는 일

기본적으로 파드를 어느 노드에 스케줄링할지 알 필요는 없다    
but..  아래의 경우에는 스케줄링한다  
- 노드의 리소스를 잘 분배해서 쓰기 위해 (결국 리소스 최적화를 위해 필요함...)  
  - eg. 트래픽이 특정시간대에 몰리는 서비스의 파드는 같은 노드에 배치하지 않기
- **GPU 계산이 필요한 파드** 인 경우 **GPU 가속을 제공하는 노드에 스케줄링**
  - **노드 레이블**과 **레이블 셀렉터**를 이용한다 (spec.nodeSelector.키:밸류)

쿠버네티스는 특정 노드를 지정하는 대신 요구사항을 기술하고, 해당 조건을 만족하는 임의의 노드에 스케줄링한다.    
장점: 실제 노드(인프라스트럭처)를 애플리케이션이 신경쓰지 않아도 된다 -> 노드가 교체되는 경우 노드를 변경하는 설정 필요없음

스케줄링에 영향을 주는 다른 방법들은 16장에서 다룸.

&nbsp;

### 파드와 어노테이션

어노테이션은 주로 도구들에서 사용된다.

eg. 오브젝트를 만든 사람 이름을 어노테이션으로 지정 => 쉽게 협업 가능

어노테이션 조회  
- kubectl describe pod 이름
  
어노테이션 추가
- kubectl annotate pod 이름 키="밸류"

&nbsp;

### 파드 중지/제거

파드 이름으로 파드 삭제
- kubectl delete po 파드이름
- kubectl delete po 파드이름1 파드이름2

레이블 셀렉터로 파드 삭제
- kubectl delete po -l 키=밸류
- kubectl delete po -l rel=canary

현재 네임스페이스의 모든 파드 삭제
- kubectl delete po -all

현재 네임스페이스의 모든 리소스 삭제
- kubectl delete all --all
- 시크릿 등의 특정 리소스는 삭제되지 않으며, 명시적으로 삭제해야 함.
