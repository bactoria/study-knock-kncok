

### 1. 이벤트 기반 마이크로서비스란?


### 2. DDD와 Boundary Context

DDD 설계 개념
- 도메인
- 하위 도메인
- 도메인(or 하위 도메인) 모델
- 바운더리 컨텍스트

`바운더리 컨텍스트`는 응집력이 강해야 한다. 컨텍스트 내부 기능은 집약적이고 깊이 연관되어 있고, 대부분의 통신이 경계를 넘나들지 않고 내부에서만 일어나야 한다. (할 일이 고도로 응집되어 있으면 그만큼 설계 범위가 좁혀지고 구현하기도 간단해진다.)

`바운더리 컨텍스트` 끼리는 느슨하게 결합해야 한다. 어떤 `바운더리 컨텍스트` 에서 일어난 변경이 인접한 컨텍스트에 미치는 영향을 최소화하거나 없애야 한다. 느슨하게 결합하면 어떤 컨텍스트에서 요건이 바뀌어도 다른 컨텍스트는 영향을 받지 않고 독립적으로 움직인다.

---

모든 조직은 도메인을 가지며, `도메인`은 다시 `하위 도메인`으로 나뉜다. eg) 기술 - 기술부서, 영업부서, 고객지원부서

`하위 도메인 모델`은 개발팀이 작고 독립적인 서비스로 옮길 수 있을 정도가 될 때까지 계속 분할된다. 

`바운더리 컨텍스트` 는 이런 `하위 도메인`을 중심으로 형성되어 마이크로서비스가 탄생하는 기초가 된다. 

---

`바운더리 컨텍스트` 는 비즈니스 요건에 따라 달라진다. 비즈니스가 변경되면 `바운더리 컨텍스트` 도 변경되기 마련이다. 따라서 `바운더리 컨텍스트`는 기술 요건이 아니라 비즈니스 요건 중심으로 정해야 한다.

`바운더리 컨텍스트`를 비즈니스 요건에 맞추면 팀별로 느슨하게 결합하며 고도로 응집된 마이크로서비스 구현체를 바꿀 수 있다. 덕분에 비즈니스에 필요한 솔루션을 자율적으로 설계/구현할 수 있고 팀 간의 복잡한 의존 관계도 엄청나게 줄어들어 팀별로 맡은 요건에만 전념할 수 있다.

**만약 기술 요건에 맞춘다면 ?**  
여러 바운더리 컨텍스트에 걸쳐 비즈니스 기능을 수행할 책임이 여러 팀으로 분산돼서 제각기 다른 스케줄로 다른 업무를 진행하게 된다. (어느 한 팀이 100% 책임지고 구현하는 것이 아님.)

eg) 동기식 point to point 마이크로서비스

단점: 따라서 하나를 고치려면 어렵고 비용도 많이 든다, 버그/장애 시 그 기술을 사용하는 모든 비즈니스 서비스 기능에 심각한 후폭풍을 가져온다.

**이벤트 기반 MSA 에서는 ?**  
이벤트 기반 MSA에서는 기술 요건에 맞출 일은 드물고 가급적이면 삼가는 것이 좋다. 팀 간의 의존성을 제거해야 시스템의 변경 민감도를 낮출 수 있기 때문이다.

<img width="466" alt="CleanShot 2021-05-05 at 17 52 46@2x" src="https://user-images.githubusercontent.com/25674959/117117751-df858280-adca-11eb-8e96-fdd4b5b8ccd4.png">

**공동 소유** 에서는 팀 간의 명확한 의존 관계가 발생할 수 밖에 없다.

`DataSource` 를 공유하거나 경계를 연결하는 식으로 반복을 줄이지 말자. 장기적이 관점에서는 로직을 반복하고 비슷한 데이터를 저장하는 것이 훨씬 값싼 비용이다.

**`바운더리 컨텍스트` 간 결합은 느슨하게 유지하고 상호 의존 관계는 최소화 하라. 왜?**   
필요시 다른 시스템에 해를 끼치지 않고 바운더리 컨텍스트 구현체를 변경하기 위해.

&nbsp;

### 3. 통신 구조

3가지 통신 구조  
1. **비즈니스 통신 구조**  
   팀과 부서 간의 통신을 결정  
  <img width="410" src="https://user-images.githubusercontent.com/25674959/117118855-3f305d80-adcc-11eb-8b7e-daa94ac05f90.png">  
2. **구현 통신 구조**  
   하위 도메인 모델에 대해 조직에서 규정한 데이터와 로직을 이용해 신속하고 효율적인 업무 수행을 위해 비즈니스 프로세스, 데이터 구조, 시스템 설계를 정규화한 것  
   <img width="410" src="https://user-images.githubusercontent.com/25674959/117118915-52dbc400-adcc-11eb-9734-29ac56625a1b.png">  
   eg) 모놀리식 DB 애플리케이션 - 상태 공유  
3. **데이터 통신 구조**  
   비즈니스 전반에 걸쳐 데이터를 주고받는 프로세스.  
   <img width="410" src="https://user-images.githubusercontent.com/25674959/117119021-7999fa80-adcc-11eb-808c-f4d5e1ad0626.png">  

**콘웨이 법칙과 통신 구조**  
ㅋㅋㅋ. 클린아키텍처에서도 콘웨이 나왔었음.  

**콘웨이 법칙**
> 시스템 구조는 그 시스템을 설계하는 조직의 통신 구조를 그대로 따라갈 수 밖에 없다.

즉, 팀은 조직의 통신 구조에 따라 제품을 만든다는 것.

- **비즈니스 통신 구조**: 사람들을 여러 팀으로 조직하고 이 팀들은 팀 경계에 의해 구분된 제품을 생산한다.
- **구현 통신 구조**: 주어진 제품의 하위 도메인 데이터 모델로 접근하는 통로를 제공한다. 데이터 통신 기능이 약하므로 다른 제품으로의 접근은 제한적이다.


**도메인**은 비즈니스를 포괄하는 개념이다.  
따라서 **도메인 데이터**는 대부분 조직의 다른 `바운더리 컨텍스트` 에서도 필요한 경우가 많다.  

**구현 통신 구조**  
다른 `바우너리 컨텍스트`의 니즈를 충족하기에는 부적절하지만, 자신의 바운더리 컨텍스트의 니즈를 충족하는 일에는 탁월하고 제품 설계에 있어서 두 가지 방향으로 영향을 미친다.

1. 조직 전체에 필요한 도메인 데이터를 통신하는 방식이 비효율적이므로 논리적으로 전혀 다른 신제품을 만드는 데 지장을 초래한다.  
2. 기존 도메인 데이터에 쉽게 접근할 수 있지만 새로운 비즈니스 요건을 수용하기 위해 지속적으로 도메인을 확장하는 위험을 무릅써야 한다.

(참고로, 이것이 모노리식 설계에 내재된 패턴이다.)

**데이터 통신 구조**  
제품을 설계/개발 하는 방법에 핵심적인 비중을 차지.  
데이터 통신 구조가 오랫동안 누락된 채 방치된 조직이 참 많다. (구현 통신 구조가 자신의 역할 외에 1인 2역을 하는 경우가 비일비재함...ㅜ)  

**eg 1) DB 공유**  
이를 해결하기 위해 DB를 공유하는 경우가 있는데, 안티패턴이 발생하기 쉽고 확장을 해도 모든 성능 요건을 충족하지 못하는 경우가 태반이다. 

**eg 2) 레플리카 DB 제공**    
내부 데이터 모델을 불필요하게 노출 시킬 필요는 없다.

**eg 3) 배치 프로세스가 데이터를 `파일 저장소에 덤프`**  
다른 프로세스가 파일을 읽어가는 방법은 진실 공급원이 다수 생성되어 데이터 일관성이 떨어진다.

무엇보다, 위 3가지 예제들은 전부 구현체를 단단히 결합시키고 직접 점대점으로 통신하게 만드는 경직된 아키텍처의 산물이다.  

**만약 조직에서 데이터 접근이 너무 어렵거나 모든 데이터가 구현체 하나에 몰려있어 제품의 범위가 한정되어 있다면 ?**  
데이터 통신 구조가 부실한 대가를 치르고 있는 것이다. 조직이 성장하고, 신제품을 개발하고, 자주 사용하는 도메인 데이터에 접근할 일이 많아질수록 문제는 점점 더 심각해질 것이다.

&nbsp;

## 기존 통신 구조 vs 이벤트 기반 통신 구조

### 4. 기본 컴퓨팅의 통신 구조 (레거시 조직)

우리팀은 단일 데이터 저장소에 기반한 단일 서비스를 담당한다. 어느 날, 신규 비즈니스가 들어왔다. 비즈니스는 기존 서비스에 붙여도 될 것 같고, 한편으로는 따로 서비스를 만들어 구현해도 될 정도로 비즈니스에 차이점이 있다. 우리팀은 선택의 갈림길에서 고민한다. 

새로운 서비스에 구현할 것인가? vs 기존 서비스에 추가할 것인가 ?

#### 1) 새로운 서비스 구현
비즈니스 요건이 많이 차이나면 서비스를 새로 만들어 구현하는 게 더 나을 수 있다. 문제는 기존 서비스의 데이터를 참조해야 한다는 점이다. 우리팀 규모는 점점 더 커지고 회사는 빠르게 성장하고 있다. 나중에 팀을 나누어야 할 수도 있다. 따라서 모듈화한 독립적인 시스템을 각각 두는 편이 소유권을 분할하기 쉽다.  
원래 데이터 저장소에 있는 데이터를 가져와 새 데이터 저장소로 복사할 방법을 강구해야 한다. 지장이 없어야 한다. 복사한 데이터는 실시간이 아니기 때문에 김빠진 데이터이다. 따라서 30분마다 실시간으로 프로덕션 데이터를 복사할 정도의 능력을 갖춰야 한다. 정확하게 실행되는지 모니터링도 해야 한다.  

**리스크**  
데이터 저장소 2개, 서비스 2개를 관리하면서 로깅, 모니터링, 테스트, 배포, 롤백 프로세스를 마련해야 하며, 데이터 구조가 조금이라도 바뀔 경우 의존 관계가 있는 타 시스템에 영향이 없도록 동기화에 만전을 가해야 한다.

&nbsp; 

#### 2) 기존 서비스에 추가  
이미 필요한 데이터가 데이터 저장소에 있다. 로깅, 모니터링, 테스트, 배포, 롤백 프로세스는 이미 구현되어 있어 바로 로직 구현에 들어갈 수 있다. 

**리스크**  
여러 모듈이 동일한 코드 베이스에 함께 엮이는 경우가 많아 변경할 일이 생기면 구현체 내부에서 경계가 모호해질 가능성이 있다. 경계를 자유롭게 넘나들면서 모듈을 직접 결합시키면 쉽고 빠르게 기능을 추가할 수 있어 유리하지만 결합도는 올라가고 응집도와 모듈성은 떨어지게 된다. 명쾌한 계획을 수립하여 서로의 경계를 확실히 지키도록 해야 한다.

#### 3) 장단점  

새로운 서비스 구현  
- 다른 시스템의 데이터에 안정적으로 접근하기 어렵다. 특히, 대규모 데이터를 실시간 접근하기 곤란하다.
  - 데이터 양이 많고 소싱이 복잡할수록 원본과 더 많이 어긋나게 된다.
- 서비스를 새로 만들어 관리하는 오버헤드와 리스크를 무시할 수 없다. 특히, 신규 서비스를 관리하는 체계가 조직 내에 아직 확립되어 있지 않다.  

&nbsp;

#### '기존 서비스에 추가' 한 후, 추후 팀이 나뉘었다면 ?
기존 서비스에 기능을 추가하고 1년이 지났다. 1년간 다른 기능들도 많이 추가되었고, 팀은 2개로 개편하게 되었다.  

이제 기존 서비스의 비즈니스 기능을 두 팀에게 각각 할당해야 한다. 

팀별 비즈니스 요건은 깔끔하게 나눌 수 있겠지만, **`구현 통신 구조`는 나누기가 어렵다.**  

예전처럼 두 팀 모두 각각 요건을 이행하려면 **동일한 데이터**가 엄청 많이 필요할 것이다.
- 어느 팀이 어떤 **데이터**를 소유해야 하는가?
- **데이터**는 어디에 두어야 하는가?
- 두 팀 모두 값을 변경하는 **데이터**는 어떻게 처리하는가?

두 팀장은 위에 대한 답을 찾지 못하여, **데이터 대신 서비스를 공유**하여 각자 다른 부분을 작업하자고 한다. 
단점: 팀 간에 긴밀한 소통을 하면서 작업을 동기화 해야하므로 생산성이 떨어진다. 


**진퇴양난**

<- 1.4.5 이해가 잘 안됨. 이벤트 기반 통신 구조 읽은 후에 다시 봐야하 할 듯.



&nbsp;

### 5. 이벤트 기반 통신 구조


&nbsp;

## 비동기식 이벤트 기반 마이크로서비스 vs 동기식 마이크로서비스

### 6. 비동기식 이벤트 기반 마이크로서비스

### 7. 동기식 마이크로서비스
